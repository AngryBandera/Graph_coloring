
**Звіт з виконання завдання "Розфарбування графу у три кольори" (задача 2-SAT)**

***Виконали:*** Труш Софія, Роман Лещук, Колодчак Богдан, Балик Микола, Пелешко Марко-Зенон

**Мета**

Розробка алгоритму та програми для розфарбування неорієнтованого графа у три кольори так, щоб жодне ребро не з'єднувало вершини одного кольору. Обов'язковою умовою є зміна кольору кожної вершини, не залишаючи попередній.

**Алгоритми, реалізація та структура проекту**

***Основні файли:***

1. **graph\_handler.py**:
   1. Вміщує алгоритми роботи з графом (Тар’яна, 2-SAT), КНФ,  та розв'язання задачі.
2. **server.py**:
   1. Інтерфейс користувача (за допомогою Streamlit), що дозволяє:
      1. Завантажувати граф із файлу.
      2. Створювати граф вручну.
      3. Генерувати випадкові графи.
      4. Візуалізувати результати та завантажувати їх.
3. **server.py**:
   1. Консольний інтерфейс користувача (за допомогою argparse), що дозволяє:
      1. Завантажувати граф із файлу та зберігати результат у файл.
      2. Запускати графічний інтерфейс.

*Процес використання програми*

1. Графічний:
   1. Користувач обирає метод введення графа:
      1. Завантаження файлу.
      2. Введення вручну кількості вершин, кольорів та ребер.
      3. Генерація випадкового графа.
   1. Система обробляє дані, визначає розфарбування та відображає його.
   2. Результат доступний для завантаження.
2. Консольний
   1. Користувач вводить команду та зазначає вхідний та вихідний файл:
      ```
      ./color_graph -i input_graph.csv -o output_graph.csv
      ```
   2. Користувач запускає графічний інтерфейс, в якому обирає подальшу дію:
      ```
      ./color_graph --visualizator
      ```

**Тепер детальніше:** 

**Graph\_handler.py - основні алгоритми, етапи**

1. Зчитування графу з файлу - функція **read\_file(filepath)**

   ***Що робить:***
   Читає файл, який містить опис графа. У файлі записано кількість вершин (точок) графа, їхні ребра (лінії між вершинами) і початкові кольори (якщо є).

   ***Як працює:***

   1. Перевіряє, чи файл має правильний формат.
   2. Зчитує рядки файлу та інтерпретує інформацію.
   3. Зберігає граф у вигляді списку списків, де кожна вершина має свій список сусідніх (зв’язків).

1. Перетворення графу в КНФ - функція **create\_cnf(graph)**

***Що робить:***

Перетворює граф у КНФ  — кон’юнктивну нормальну форму для перевірки логічних умов.

***Як працює:***

- Для кожної вершини визначає, які кольори можуть бути використані (всього 3 кольори)
- Додає умови: сусідні вузли не можуть мати однаковий колір.

2. Перетворення КНФ в імплікаційний граф - **create\_implication\_graph(cnf, vertexes\_count)**

   ***Що робить:***
   Створює імплікаційний граф між умовами, що виникають з КНФ.

   ***Як працює:***

   - Створює список списків, де індекс кожного списку відповідає за вершину імплікаційного графа, а елементи, які містяться в ньому - вершини, до яких йде імплікація.

3. Алгоритм 2-SAT, який включає в себе алгоритм Тар’яна для пошуку сильнозв’язнизних компонент та визначення чи існує розв’язок КНФ + присвоєння атомам True або False - **find\_solution(implication\_grap)**

   ***Що робить:***
   Шукає рішення для розфарбування графа, яке відповідає всім умовам. Якщо це неможливо, повертає відповідне повідомлення.

Функція приймає імплікаційний граф та шукає розв'язок відповідної КНФ, для якого цей граф був складений, за допомогою алгоритму 2-SAT. Для цього спершу для кожної вершини імплікаційного графу присвоюється номер її сильно зв'язної компоненти за допомогою алгоритму Тар'яна, а тоді використовується властивість, що цим алгоритмом нумерація сильно зв'язних компонент проходить у зворотному топологічному порядку, що дозволяє не лише перевірити існування розв'язку, але і знайти його.

***Як працює:***

1. Аналізує всі залежності у графі умов, щоб переконатись, що немає конфліктів.
2. Використовує спеціальний алгоритм (алгоритм Тар’яна) для пошуку сильнозв’язних компонентів.

3. Перетворення розв’яку 2-SAT в кольори - **color\_graph(cnf\_solution)**

   ***Що робить:***
   Перетворює отриманий розв’язок КНФ у список кольорів для кожної вершини графа - кінцеве розфврбування вершин графа.

   ***Як працює:***

   1. Для кожної вершини визначає, який із кольорів можна використати на основі рішення.
   2. Якщо рішення немає, повертає відповідне повідомлення.

4. Записування інформації про граф у файл - **write\_file(graph, colored\_graph, output\_file)**

   ***Що робить:***
   Зберігає результати роботи у файл: граф із кольорами вершин.

   ***Як працює:***

   1. Формує текстовий файл із інформацією про кількість вершин, кольори і ребра між ними.
   2. Якщо файл не задано, повертає цей опис у вигляді тексту.

5. Тестування програми на різних графах - **generate\_graph(num\_nodes, density)**

   ***Що робить:***
   Генерує випадковий граф із заданою кількістю вершин і зв’язків між ними.

   ***Як працює:***

   1. Створює вершини, кожній з яких присвоює випадковий початковий колір.
   2. Додає випадкові зв’язки між вершинами на основі щільності.

6. Результат чи успішне розфарбування + нові кольори вершин - **create\_colored\_graph(graph)**

   ***Що робить:***
   Об’єднує всі попередні функції для виконання основної задачі — розфарбування графа.

   ***Як працює:***

   - Створює CNF і імплікаційний граф.
   - Шукає розв’язок і генерує список кольорів для кожної вершини.
   - Якщо рішення немає, повертає відповідну відповідь.

**server.py** **- алгоритм для візуалізації**

1. **validate\_graph\_file**

*Функція перевіряє коректність файлу графа, який завантажується користувачем:*

- Перевіряє перший рядок: формат має бути {кількість\_вершин},{кількість\_ребер}, де обидва значення — цілі числа.
- Перевіряє другий рядок: список кольорів вершин у вигляді комами розділених чисел (0 = червоний, 1 = зелений, 2 = синій).
- Перевіряє кожен рядок із 3-го: формат ребер має бути {u},{v}, де u та v — індекси вершин.

*Повертає*:

- (True, "Valid file.") у разі успішної валідації.
- (False, "Error message.") у разі помилок із поясненням, що не так.

2. **graph\_from\_data**

*Приймає дані про граф:*

- nodes\_num: кількість вершин.
- edges: список ребер, де кожне ребро у форматі [u, v].
- oldcolors: список кольорів вершин до фарбування.

*Перетворює граф у внутрішній формат "factor set":*

- Кожній вершині (ключ у словнику) присвоюється множина сусідніх вершин.
- Потім ці множини конвертуються у формат списку суміжностей.

*Повертає список пар, де кожен елемент —* (список сусідів вершини, її початковий колір).

3. **draw\_graph**

*Функція для візуалізації графа:*

- Приймає кількість вершин, список ребер і кольори вершин.
- Перетворює граф у внутрішній формат (викликає graph\_from\_data).
- Викликає алгоритм фарбування (create\_colored\_graph), який намагається знайти розв'язок (забарвлення графа).
- Якщо фарбування успішне:
- Створює об'єкт графа через NetworkX.
- Додає вершини та ребра.
- Призначає кольори кожній вершині.
- Використовує Matplotlib для побудови графа.
- Зберігає зображення у буфер.
- Якщо фарбування неможливе, повертає повідомлення про помилку.

*Повертає*:

- Статус успіху (True/False).
- Буфер із зображенням графа.
- Дані графа для збереження у файл.

4. **parse\_graph**

*Функція розбирає вхідний файл графа:*

- Перший рядок розділяє комами для отримання кількості вершин і ребер.
- Другий рядок розділяє комами для отримання списку кольорів вершин.
- Залишок рядків інтерпретується як список ребер.

*Повертає*:

- Кількість вершин (int).
- Список ребер (list).
- Список кольорів вершин (list).

5. **main**

*Головна функція, що реалізує веб-інтерфейс через Streamlit. Забезпечує: вибір способу введення графа:*
1. Ручне введення:
- Користувач задає кількість вершин і ребер.
- Вводить кольори кожної вершини (через текстове поле).
- Вказує список ребер у форматі u,v.
- Якщо введені дані валідні, будується граф із використанням draw\_graph.
- У разі помилок — повідомляє про неправильний формат.
2. Завантаження файлу:
- Користувач завантажує файл формату CSV.
- Перевіряється коректність файлу (validate\_graph\_file).
- У разі успішної перевірки, дані передаються у draw\_graph.
3. Генерація випадкового графа:
- Користувач задає кількість вершин і щільність графа.
- Граф генерується автоматично (generate\_graph).
- Результат передається у draw\_graph для побудови.

***Додаткові функції у main:***

- Відображення побудованого графа як зображення.
- Можливість завантажити файл із результатами (забарвлені вершини і ребра).
- Динамічне оновлення залежно від обраного способу введення.

**color\_graph.py - інтерфейс командного рядка**

1. **main**
   1. Використовує бібліотеку argparse, аби взаємодіяти з користувачем через командний рядок
   2. Надає можливість запускати алгоритм, надаючи вхідний файл і записуючи результат у вихідний файл
   3. Надає можливість запускати графічний інтерфейс

**Принципи дискретної математики, використані для реалізації функцій основного алгоритму:**

- знання про неорієнтований граф: що це і які маніпуляції можна з ним зробити
- розуміння, що таке КНФ
- процес перетворення неорієнтованого графа в імплікаційний (зокрема як з його КНФ отримати імплікаційний граф)
- ключові концепції роботи з орієнтованими графами, зокрема представлення графа у вигляді списків суміжностей (це дозволяє перебирати лише сусідні вершини, на відміну від матриці суміжностей)
- рекурсивний обхід графа в глибину
- важливість концепції сильно зв'язних компонент для розв'язання різноманітних задач (в тому числі 2-SAT)
- алгоритм Тар'яна, за допомогою якого ми знаходили сильно зв'язні компоненти за O(n) у зворотному топологічному порядку

Перед тим як приступити до реалізації програми, кожен учасник команди розібрався з цими принципами, що значно полегшило в подальшому написання коду.

**Розподіл роботи**

Загалом, обговорювали структуру і алгоритм для розв’язання задачі ми спільно, на кількох зустрічах. Однак, мали такий розподіл обовʼязків:

- Зчитування графу з файлу - Пелешко Марко
- Перетворення графу в КНФ - Колодчак Богдан
- Перетворення КНФ в імплікаційний граф - Труш Софія
- Алгоритм 2-SAT, який включає в себе алгоритм Тар’яна для пошуку сильнозв’язнизних компонент та визначення чи існує розв’язок КНФ + присвоєння атомам True або False - Роман Лещук
- Перетворення розв’яку 2-SAT в кольори - Роман Лещук
- Створення користувацького інтерфейсу та функцій візуалізації — Балик Микола.
- Створення інтерфейсу командного рядка - Роман Лещук
- Звіт - Труш Софія

**Враження та фідбек**

Поділившись спільними враженнями про виконання роботи, провівши міні-рефлексію, можна зробити такий підсумок:

Робота над проєктом виявилася цікавою, пізнавальною, а головне корисною. На перший погляд вона здавалась складною та незрозумілою для більшості учасників, але це не завадило нашій команді розібратися та знайти оптимальне рішення. Цей проєкт дав нам чудову можливість зануритися у вивчення нових концепцій і алгоритмів, зокрема таких як алгоритм Тар’яна та алгоритм 2-SAT, а також поглибити вже набуті знання, що дозволило покращити розуміння певних тем з дискретної математики.

Для кожного з нас це був не просто навчальний досвід, а й можливість розвинути свої навички командної роботи. У нашій групі панувала атмосфера підтримки та взаєморозуміння, що зробило співпрацю комфортною та ефективною.

Важливо також, що за кожною групою був закріплений ментор, адже це значно спрощувало завдання командам, оскільки ми в будь-який момент могли звернутися за допомогою чи уточненнями щодо виконання задачі. Така підтримка створювала додаткову впевненість і допомагала уникнути непорозумінь. Інколи цю функцію ментора в нашій команді виконував Лещук Роман:) Проте, загалом, ментор - дуже потрібна складова цього проєкту.

Отже, на нашу спільну думку, цей комп’ютерний проєкт є важливою складовою курсу, яка допомагає значно покращити практичні навички та знання з дискретної математики, а також набути певного досвіду командної роботи.
